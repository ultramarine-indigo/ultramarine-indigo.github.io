<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ultramarine-indigo.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Linux操作系统的内核是单一体系结构(monolithic kernel)的。也就是说，整个内核是一个单独的非常大的程序。为了改善单一体系结构的可扩展性、可维护性等，Linux操作系统使用了一种全新的内核模块机制。用户可以根据需要，在不需要对内核重新编译的情况下，模块能动态地装入内核或从内核移出。">
<meta property="og:type" content="article">
<meta property="og:title" content="linux内核模块设计">
<meta property="og:url" content="http://ultramarine-indigo.github.io/2023/06/18/linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="ultramarine&#39;s Blog">
<meta property="og:description" content="Linux操作系统的内核是单一体系结构(monolithic kernel)的。也就是说，整个内核是一个单独的非常大的程序。为了改善单一体系结构的可扩展性、可维护性等，Linux操作系统使用了一种全新的内核模块机制。用户可以根据需要，在不需要对内核重新编译的情况下，模块能动态地装入内核或从内核移出。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ultramarine-indigo/ultramarine-indigo.github.io/main/imgs/Linux内核设计-1.png">
<meta property="article:published_time" content="2023-06-18T12:25:14.000Z">
<meta property="article:modified_time" content="2023-11-06T14:46:01.367Z">
<meta property="article:author" content="Ultramarine">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ultramarine-indigo/ultramarine-indigo.github.io/main/imgs/Linux内核设计-1.png">


<link rel="canonical" href="http://ultramarine-indigo.github.io/2023/06/18/linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://ultramarine-indigo.github.io/2023/06/18/linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/","path":"2023/06/18/linux内核模块设计/","title":"linux内核模块设计"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>linux内核模块设计 | ultramarine's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ultramarine's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section">关于</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section">标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section">分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section">归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%A6%82%E8%BF%B0"><span class="nav-text">1. 内核模块概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%89%B9%E7%82%B9"><span class="nav-text">1.1 内核模块特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-text">1.2 内核模块实现机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">1.2.1 内核模块和应用程序的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="nav-text">1.2.2 内核符号表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96"><span class="nav-text">1.2.3 模块依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81"><span class="nav-text">1.2.4 内核代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-text">1.3 内核模块的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-text">1.3.1 模块的加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="nav-text">1.3.2 模块的卸载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8Fmodutils"><span class="nav-text">1.3.3 模块实用程序modutils</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="nav-text">1.4 模块与系统内核的交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile%E6%96%87%E4%BB%B6"><span class="nav-text">Makefile文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB"><span class="nav-text">2. 打印进程之间父子关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3task_struct"><span class="nav-text">2.1 理解task_struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8"><span class="nav-text">2.2 linux内核链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list_for-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="nav-text">2.3 list_for 内核链表遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#list_for_each"><span class="nav-text">2.3.1 list_for_each</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list_for_each_entry"><span class="nav-text">2.3.2 list_for_each_entry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list_for_each_entry%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-text">2.3.3
list_for_each_entry()参数分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B8%A9%E5%9D%91"><span class="nav-text">2.4 踩坑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8procstat%E5%BE%97%E5%88%B0cpu%E5%8D%A0%E7%94%A8"><span class="nav-text">3. 利用proc&#x2F;stat&#x2F;得到CPU占用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3procstat%E7%BB%93%E6%9E%84"><span class="nav-text">3.1 理解proc&#x2F;stat&#x2F;结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kernal_read%E8%AF%BB%E5%8F%96"><span class="nav-text">3.2 kernal_read()读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97cpu%E5%8D%A0%E7%94%A8"><span class="nav-text">3.3 监控内核模块CPU占用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-text">4. 查看系统内存占用情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3sys_info%E7%BB%93%E6%9E%84"><span class="nav-text">4.1 理解sys_info结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3si_meminfo-%E5%87%BD%E6%95%B0"><span class="nav-text">4.2 理解si_meminfo 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8Esys_info%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-text">4.3
从sys_info中获取内存使用情况</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ultramarine"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Ultramarine</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ultramarine-indigo.github.io/2023/06/18/linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Ultramarine">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ultramarine's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="linux内核模块设计 | ultramarine's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux内核模块设计
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-18 20:25:14" itemprop="dateCreated datePublished" datetime="2023-06-18T20:25:14+08:00">2023-06-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>Linux操作系统的内核是单一体系结构(monolithic
kernel)的。也就是说，整个内核是一个单独的非常大的程序。为了改善单一体系结构的可扩展性、可维护性等，Linux操作系统使用了一种全新的内核模块机制。用户可以根据需要，在不需要对内核重新编译的情况下，模块能动态地装入内核或从内核移出。</p>
<span id="more"></span>
<h2 id="内核模块概述">1. 内核模块概述</h2>
<p>模块是在内核空间运行的程序，实际上是一种目标对象文件，没有链接，不能独立运行，但是其代码可以在运行时链接到系统中作为内核的一部分运行或从内核中取下，从而可以动态扩充内核的功能。这种目标代码通常由一组函数和数据结构组成，用来实现一种文件系统，一个驱动程序，或其它内核上层的功能。模块机制的完整叫法应该是动态可加载内核模块(Loadable
Kernel Module)或
LKM，一般就简称为模块。与前面讲到的运行在微内核体系操作系统的外部用户空间的进程不同，模块不是作为一个进程执行的，而像其他静态连接的内核函数一样，它在内核态代表当前进程执行。由于引入了模块机制，Linux的内核可以达到最小，即内核中实现一些基本功能，如从模块到内核的接口，内核管理所有模块的方式等等，而系统的可扩展性就留给模块来完成。</p>
<h3 id="内核模块特点">1.1 内核模块特点</h3>
<p><strong>优点：</strong></p>
<ol type="1">
<li>使得内核更加紧凑和灵活</li>
<li>修改内核时，不必全部重新编译整个内核，可节省不少时间，避免人工操作的错误。系统中如果需要使用新模块，只要编译相应的模块然后使用特定用户空间的程序将模块插入即可。</li>
<li>模块可以不依赖于某个固定的硬件平台。</li>
<li>模块的目标代码一旦被链接到内核，它的作用和静态链接的内核目标代码完全等价。
所以，当调用模块的函数时，无须显式的消息传递。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol type="1">
<li>由于内核所占用的内存是不会被换出的，所以链接进内核的模块会给整个系统带来一定的性能和内存利用方面的损失。</li>
<li>装入内核的模块就成为内核的一部分，可以修改内核中的其他部分，因此，模块的使用不当会导致系统崩溃。</li>
<li>为了让内核模块能访问所有内核资源，内核必须维护符号表，并在装入和卸载模块时修改符号表。</li>
<li>模块会要求利用其它模块的功能，所以，内核要维护模块之间的依赖性。</li>
</ol>
<h3 id="内核模块实现机制">1.2 内核模块实现机制</h3>
<h4 id="内核模块和应用程序的比较">1.2.1 内核模块和应用程序的比较</h4>
<table>
<thead>
<tr class="header">
<th>应用程序</th>
<th>内核模块</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>入口</td>
<td>main()</td>
</tr>
<tr class="even">
<td>出口</td>
<td>无</td>
</tr>
<tr class="odd">
<td>编译</td>
<td>gcc -c</td>
</tr>
<tr class="even">
<td>链接</td>
<td>gcc</td>
</tr>
<tr class="odd">
<td>运行</td>
<td>无</td>
</tr>
<tr class="even">
<td>调试</td>
<td>gdb</td>
</tr>
</tbody>
</table>
<h4 id="内核符号表">1.2.2 内核符号表</h4>
<p>内核符号表是一个用来存放所有模块可以访问的那些符号以及相应地址的特殊的表。模块的连接就是将模块插入到内核的过程。模块所声明的任何全局符号都成为内核符号表的一部分。内核模块根据系统符号表从内核空间中获取符号的地址，从而确保在内核空间中正确地运行。
这是一个公开的符号表，我们可以从文件/proc/kallsyms中以文本的方式读取。在这个文件中存放数据地格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存地址 属性 符号名称 【所属模块】</span><br></pre></td></tr></table></figure>
<p>在模块编程中，可以利用符号名称从这个文件中检索出该符号在内存中的地址，然后直接对该地址内存访问从而获
得内核数据。对于通过内核模块方式导出的符号，会包含第四列“所属模块”，用来标志这个符号所属的模块名称；而对于从内核中释放出的符号就不存在这一列的数据了。
内核符号表处于内核代码段的_ksymtab部分，其开始地址和结束地址是由C编译器所产生的两个符号来指定：<strong>start</strong>_ksymtab和__stop___ksymtab</p>
<p>在模块编程中，可以利用符号名称从这个文件中检索出该符号在内存中的地址，然后直接对该地址内存访问从而获得内核数据。对于通过内核模块方式导出的符号，会包含第四列“所属模块”，用来标志这个符号所属的模块名称；而对于从内核中释放出的符号就不存在这一列的数据了。
内核符号表处于内核代码段的_ksymtab部分，其开始地址和结束地址是由C编译器所产生的两个符号来指定：<strong>start</strong>_ksymtab和__stop___ksymtab</p>
<h4 id="模块依赖">1.2.3 模块依赖</h4>
<p>内核符号表记录了所有模块可以访问的符号及相应地址。一个内核模块被装入后，它所声明的符号就会被记录到这个表里，而这些符号当然就可能会被其他模块所引用。
一个模块A引用另一个模块B所导出的符号，我们就说模块B被模块A引用，或者说模块A装载到模块B的上面。如果要链接模块A，必须先要链接模块B。否则，模块B所导出的那些符号的引用就不可能被链接到模块A中。这种模块间的相互关系就叫做模块依赖。</p>
<h4 id="内核代码">1.2.4 内核代码</h4>
<p><strong>数据结构</strong></p>
<p>跟模块有关的数据结构存放在include/linux/module.h中。在内核中，每一个内核模块信息都由一个module对象来描述。所有的module对象通过list链接在一起。链表的第一个元素由static
LIST_HEAD(modules)建立，见kernel/module.c第65行。如果阅读include/linux/list.h里面的LIST_HEAD宏定义，modules变量是struct
list_head类型结构，结构内部的next指针和prev指针，初始化时都指向modules本身。对modules链表的操作，受module_mutex和modlist_lock保护。</p>
<p><strong>实现函数</strong></p>
<p>操作系统初始化时，static
LIST_HEAD(modules)已经建立了一个空链表。之后，每装入一个内核模块，则创建一个module结构，并把它链接到modules链表中。通过系统调用init_module装入内核模块，通过系统调用delete_module卸载内核模块。</p>
<h3 id="内核模块的用法">1.3 内核模块的用法</h3>
<h4 id="模块的加载">1.3.1 模块的加载</h4>
<p>系统调用当然是将内核模块插入到内核的可行方法。此外，Linux环境里还有两种方法可达到此目的。</p>
<ul>
<li>modprobe程序：可以做到需要时自动装入，不需要时自动卸载。</li>
<li>insmod命令：手工装入内核模块。</li>
</ul>
<p><strong>insmod命令</strong></p>
<p>insmod的作用就是将需要插入的模块以目标代码的形式插入到内核中。注意，只有超级用户才能使用这个命令。insmod的格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># insmod [path]modulename.ko</span><br></pre></td></tr></table></figure>
<p>insmod其实是一个modutils模块实用程序，当我们以超级用户的身份使用这个命令的时候，这个程序完成下面一系列工作：</p>
<ol type="1">
<li>从命令行中读入要链接的模块名，通常是扩展名为“.ko”，elf格式的目标文件。</li>
<li>确定模块对象代码所在文件的位置。通常这个文件都是在lib/modules的某个子目录中。</li>
<li>计算存放模块代码、模块名和module对象所需要的内存大小。</li>
<li>在用户空间中分配一个内存区，把module对象、模块名以及为正在运行的内核所重定位的模块代码拷贝到这个内存里。其中，module对象中的init域指向这个模块的入口函数重新分配到的地址；exit域指向出口函数所重新分配的地址。</li>
<li>调用init_module()，向它传递上面所创建的用户态的内存区的地址，其实现过程我们已经详细分析过了。</li>
<li>释放用户态内存, 整个过程结束。</li>
</ol>
<h4 id="模块的卸载">1.3.2 模块的卸载</h4>
<p>卸载一个内核模块使用rmmod命令。rmmod程序将已经插入内核的模块从内核中移出，rmmod会自动运行在内核模块自己定义的出口函数。当然，它最终还是通过delete_module()系统调用实现的。它的格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rmmod [path]modulename</span><br></pre></td></tr></table></figure>
<h4 id="模块实用程序modutils">1.3.3 模块实用程序modutils</h4>
<p>Linux内核模块机制提供的系统调用大多数都是为modutils程序使用的。可以说，是Linux的内核模块机制和modutils两者的结合提供了模块的编程接口。modutils(modutils-x.y.z.tar.gz)可以在任何获得内核源代码的地方获得,
选择最高级别的patchlevel
x.y.z等于或者小于当前的内核版本，安装后在/sbin目录下就会有insmod、rmmod、ksyms、lsmod、modprobe等等实用程序。当然，通常我们在加载Linux内核的时候，modutils已经被装入了。</p>
<h3 id="模块与系统内核的交互">1.4 模块与系统内核的交互</h3>
<h4 id="makefile文件">Makefile文件</h4>
<p><strong>单文件Makefile文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET = helloworld</span><br><span class="line"> </span><br><span class="line">KDIR = /usr/src/linux</span><br><span class="line"> </span><br><span class="line">PWD = $(shell pwd)</span><br><span class="line"> </span><br><span class="line">obj-m += $(TARGET).o</span><br><span class="line"> </span><br><span class="line">default:</span><br><span class="line"> </span><br><span class="line">       make -C $(KDIR) M=$(PWD) modules</span><br></pre></td></tr></table></figure>
<ul>
<li>TARGET：内核名称</li>
<li>$(KDIR)表示源代码最高层目录的位置。</li>
<li>obj-m += <span
class="math inline">\((TARGET).o：告诉kbuild，希望将\)</span>(TARGET)，也就是helloworld，编译成内核模块。</li>
<li>M=$(PWD)：表示生成的模块文件都将在当前目录下。</li>
</ul>
<p><strong>多文件Makefile文件</strong></p>
<p>此时helloworld内核模块由两个源文件组成，即start.c和stop.c
相比单文件，只增加一行： $(TARGET)-y := start.o stop.o</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TARGET = helloworld</span><br><span class="line"> </span><br><span class="line">KDIR = /usr/src/linux</span><br><span class="line"> </span><br><span class="line">PWD = $(shell pwd)</span><br><span class="line"> </span><br><span class="line">obj-m += $(TARGET).o</span><br><span class="line"> </span><br><span class="line">$(TARGET)-y := start.o stop.o</span><br><span class="line"> </span><br><span class="line">default:</span><br><span class="line"> </span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules</span><br></pre></td></tr></table></figure>
<h2 id="打印进程之间父子关系">2. 打印进程之间父子关系</h2>
<h3 id="理解task_struct">2.1 理解task_struct</h3>
<p>除了0号进程以外，其他进程都是有父进程的。全部进程其实就是一颗进程树，相关成员变量如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">real_parent</span>;</span> <span class="comment">/* real parent process */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">parent</span>;</span> <span class="comment">/* recipient of SIGCHLD, wait4() reports */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>      <span class="comment">/* list of my children */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>       <span class="comment">/* linkage in my parent&#x27;s children list */</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>parent 指向其父进程。当它终止时，必须向它的父进程发送信号。</li>
<li>children 指向子进程链表的头部。链表中的所有元素都是它的子进程。</li>
<li>sibling 用于把当前进程插入到兄弟链表中。</li>
</ul>
<p>通常情况下，real_parent 和 parent
是一样的，但是也会有另外的情况存在。例如，bash 创建一个进程，那进程的
parent 和 real_parent 就都是 bash。如果在 bash 上使用 GDB 来 debug
一个进程，这个时候 GDB 是 parent，bash 是这个进程的 real_parent。</p>
<p><strong>p-&gt;mm</strong></p>
<p>如果p-&gt;mm为空，则意味着该进程无用户空间（例如内核线程），则无需切换到用户空间。如果p-&gt;mm=this_mm，则说明该进程的用户空间就是当前进程的用户空间，该进程完全有可能再次得到运行。</p>
<p><strong>p-&gt;prio</strong></p>
<p>进程优先级。prio
的值是调度器最终使用的优先级数值，即调度器选择一个进程时实际选择的值。<strong>prio
值越小，表明进程的优先级越高</strong>。prio 值的取值范围是 0 ~
MAX_PRIO，即 0 ~ 139（包括 0 和
139），根据调度策略的不同，又可以分为两个区间，其中区间 0 ~ 99
的属于实时进程，区间 100 ~139 的为非实时进程。</p>
<h3 id="linux内核链表">2.2 linux内核链表</h3>
<p>链表数据结构的定义很简单（节选自[include/linux/list.h]，以下所有代码，除非加以说明，其余均取自该文件）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct list_head &#123;</span><br><span class="line">struct list_head *next, *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>list_head结构包含两个指向list_head结构的指针prev和next，由此可见，内核的链表具备双链表功能，实际上，通常它都组织成双循环链表。
Linux用头指针的next是否指向自己来判断链表是否为空</p>
<h3 id="list_for-内核链表遍历">2.3 list_for 内核链表遍历</h3>
<h4 id="list_for_each">2.3.1 list_for_each</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list_for_each内核中的定义：</span><br><span class="line">/**</span><br><span class="line"> * list_for_each - iterate over a list</span><br><span class="line"> * @pos: the &amp;struct list_head to use as a loop cursor.</span><br><span class="line"> * @head: the head for your list.</span><br><span class="line"> */</span><br><span class="line">#define list_for_each(pos, head) \</span><br><span class="line">for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>循环的初始化工作：pos指向链表头的下一项。</li>
<li>循环的条件：pos不是链表头。</li>
<li>每次循环要做的事情：pos指向链表中的下一项</li>
</ol>
<h4 id="list_for_each_entry">2.3.2 list_for_each_entry</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#define list_entry(ptr, type, member) \</span><br><span class="line">    container_of(ptr, type, member)</span><br><span class="line"> </span><br><span class="line">#define container_of(ptr, type, member) (&#123;          \</span><br><span class="line">    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \</span><br><span class="line">    (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span><br><span class="line"></span><br><span class="line">#define list_entry(ptr, type, member) /</span><br><span class="line">        ((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * list_for_each_entry - iterate over list of given type</span><br><span class="line"> * @pos: the type * to use as a loop cursor.</span><br><span class="line"> * @head: the head for your list.</span><br><span class="line"> * @member: the name of the list_struct within the struct.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#define list_for_each_entry(pos, head, member) \</span><br><span class="line">for (pos = list_entry((head)-&gt;next, typeof(*pos), member); \</span><br><span class="line">    &amp;pos-&gt;member != (head); \</span><br><span class="line">    pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>for循环初始化 pos = list_entry((head)-&gt;next, typeof(*pos),
member);</li>
<li>for循环执行条件 &amp;pos-&gt;member != (head);</li>
<li>每循环一次执行 pos = list_entry(pos-&gt;member.next, typeof(*pos),
member))</li>
</ol>
<p>**list_entry详解：&amp;((type *)0)-&gt;member)) 将地址 0 转换为 type
类型的指针，通过该指针去访问 member 就可以取出其地址**。前半部分 (char
*)(ptr) 使得指针的加减为 1 字节，最后将地址转换为 type 类型的指针。</p>
<p><strong>区别：</strong></p>
<ul>
<li>list_for_each遍历的链表，其链表项不属于某个结构体。或者说不关心它是不是包含在某个结构体中。</li>
<li>list_for_each_entry遍历的链表，其每一项都是某个结构体中的成员，单纯遍历链表还不行，还要找到包含这个</li>
</ul>
<h4 id="list_for_each_entry参数分析">2.3.3
list_for_each_entry()参数分析</h4>
<p>task_struct 中 parent/children/sibling 三者的关系：</p>
<p><img src="https://raw.githubusercontent.com/ultramarine-indigo/ultramarine-indigo.github.io/main/imgs/Linux内核设计-1.png" alt="Linux内核设计-1" style="zoom: 33%;" /></p>
<ul>
<li>sibling.next指向进程的下一个兄弟进程的进程描述符sibling成员，若其后没有其他兄弟进程，则指向父进程；而sibling.prev指向进程的上一个兄弟进程，若其之前没有兄弟进程，则指向父进程。</li>
<li>children.next指向父进程的第一个子进程的sibling成员（而不是children成员！），而children.prev却指向父进程的最后一个子进程的sibling成员。
特别注意children.next指向的是sibling成员，因此在使用list_entry()获得task_struct指针时，参数要用sibling而不是children，更不是tasks成员。</li>
</ul>
<p>遍历子进程的两种写法：</p>
<ol type="1">
<li>使用list_for_each_entry:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry(pos, &amp;(p-&gt;children), sibling)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;%-10s%-20s%-6d%-6d\n&quot;, ptype[3], pos-&gt;comm, pos-&gt;pid,pos-&gt;state);</span><br><span class="line">&#125; </span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用list_for_each:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list_for_each(pos, &amp;(p-&gt;children)</span><br><span class="line">&#123;</span><br><span class="line">    psibling=list_entry(pos,struct task_struct, sibling);</span><br><span class="line">    printk(&quot;%-10s%-20s%-6d%-6d\n&quot;, ptype[3], pos-&gt;comm, pos-&gt;pid,pos-&gt;state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="踩坑">2.4 踩坑</h3>
<p>pstree系列命令（pstree -p 或者pstree
-up）会在日志中打印进程树出来，可以看到进程树中有些进程的名字被{
}括着，这些被{
}括着的进程是进程组的一部分。在Linux系统中，进程可以分组为进程组，一个进程组可以包含多个进程，这些进程正在相互协作。而{
}中的进程们的父进程并不是他们前面那个同名进程，而是是启动该进程组的进程。当一个进程创建新的进程组时，它将成为这个新进程组的进程组头进程，这个进程组头进程将成为新进程组中创建的所有进程的父进程。
比如下图中，583号进程并不是567进程的孩子。而查看1号进程的孩子会看到567，也不会看到583<img
src="https://raw.githubusercontent.com/ultramarine-indigo/ultramarine-indigo.github.io/main/imgs/Linux内核设计-2.png"
alt="Linux内核设计-2" /></p>
<h2 id="利用procstat得到cpu占用">3. 利用proc/stat/得到CPU占用</h2>
<p>CPU占用指的是计算机中中央处理器（CPU）正在执行某个程序时所占用的系统资源的百分比。它是衡量计算机性能的一个重要指标，通常用于评估一个程序的效率和优化性能。</p>
<p>一种获取 CPU 使用情况的方法是使用 <code>/proc/stat</code>
文件。该文件包含了当前系统的各个 CPU 的运行情况，包括 CPU
时间以及一些统计信息等。具体来说，可以通过解析该文件的内容，计算出 CPU
的使用情况。</p>
<h3 id="理解procstat结构">3.1 理解proc/stat/结构</h3>
<p>在Linux系统中，/proc/stat文件提供了有关系统CPU和其他资源使用情况的信息。/proc/stat文件中的第一行包含的是有关CPU总体使用情况的信息，该行的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1   user	Time spent with normal processing in user mode.</span><br><span class="line">2	nice	Time spent with niced processes in user mode.</span><br><span class="line">3	system	Time spent running in kernel mode.</span><br><span class="line">4	idle	Time spent in vacations twiddling thumbs.</span><br><span class="line">5	iowait	Time spent waiting for I/O to completed. This is considered idle time too.	</span><br><span class="line">6	irq	Time spent serving hardware interrupts. See the description of the intr line for more details.</span><br><span class="line">7	softirq	Time spent serving software interrupts.	</span><br><span class="line">8	steal	Time stolen by other operating systems running in a virtual environment.	</span><br><span class="line">9	guest	Time spent for running a virtual CPU or guest OS under the control of the kernel.	</span><br></pre></td></tr></table></figure>
<ul>
<li><code>user</code>:
CPU处于用户模式下的时间，单位为jiffies（1jiffies等于1/100秒）</li>
<li><code>nice</code>: CPU处于低优先级用户模式下的时间</li>
<li><code>system</code>: CPU处于系统模式下的时间</li>
<li><code>idle</code>: CPU处于空闲状态的时间</li>
<li><code>iowait</code>: CPU等待IO操作完成的时间</li>
<li><code>irq</code>: CPU处理硬件中断的时间</li>
<li><code>softirq</code>: CPU处理软件中断的时间</li>
<li><code>steal</code>: 虚拟化环境中，CPU被其他虚拟机占用的时间</li>
<li><code>guest</code>: CPU运行虚拟CPU的时间</li>
<li><code>guest_nice</code>: CPU运行低优先级虚拟CPU的时间</li>
</ul>
<p>/proc/stat文件中除了第一行之外，每一行表示一个逻辑CPU核的使用情况。例如，在一个4核CPU的系统中，/proc/stat文件中就会有5行（包括总体使用情况的一行和4个逻辑CPU核的使用情况）。</p>
<p>理解/proc/stat文件中的数据对于优化Linux系统性能和监控系统状态都非常重要。可以使用工具如top、vmstat等查看/proc/stat文件的信息，以便更好地了解系统的CPU和其他资源使用情况。</p>
<h3 id="kernal_read读取">3.2 kernal_read()读取</h3>
<p>需要调试的驱动程中读写文件数据，比如说当驱动需要记录的日志比较多的情况下，可以将printk()函数打印的信息都写到文件做后续分析。在kernel中操作文件没有标准库可用，需要利用kernel的一些函数，这些函数主要有：
filp_open() filp_close(),
kernel_read()，kernel_write()这些函数在linux/fs.h和asm/uaccess.h头文件中声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">kernel_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = rw_verify_area(READ, file, pos, count);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">return</span> __kernel_read(file, buf, count, pos);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kernel_read);</span><br></pre></td></tr></table></figure>
<h3 id="监控内核模块cpu占用">3.3 监控内核模块CPU占用</h3>
<p>我们利用kernel_read读取系统proc/stat中提供的CPU时间的占用信息来监控当前内核模块的CPU使用情况。由于模块运行一次的时间很多，小于一个时间片的长度，所以直接读取得到的信息是没有意义的。所以我们通过将内核模块重复运行1000次。然后在内核模块运行过程中，每个一段固定的时间来读取proc/stat中的信息。然后计算在这一个时间间隔内，内核模块的CPU使用情况。</p>
<p>其中当前内核模块的CPU利用率：proc/stat中system项下的时间差值与这个时间段时间的比值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU利用率 = 100 * (user + nice + system + irq + softirq + steal) / (user + nice + system + irq + softirq + steal + idle)</span><br></pre></td></tr></table></figure>
<p>最终实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cpu_usage_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">proc_stat</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> user, nice, system, idle, iowait, irq, softirq, steal, guest, guest_nice;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> total1, total2, busy1, busy2, busy, usage;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开 /proc/stat 文件</span></span><br><span class="line">    proc_stat = filp_open(<span class="string">&quot;/proc/stat&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!proc_stat || IS_ERR(proc_stat)) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to open /proc/stat\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取 /proc/stat 文件的内容</span></span><br><span class="line">    len = kernel_read(proc_stat, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to read /proc/stat\n&quot;</span>);</span><br><span class="line">        filp_close(proc_stat, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    filp_close(proc_stat, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析 /proc/stat 文件的内容，获取 CPU 时间信息</span></span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;cpu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu&quot;</span>, &amp;user, &amp;nice, &amp;system, &amp;idle, &amp;iowait, &amp;irq, &amp;softirq, &amp;steal, &amp;guest, &amp;guest_nice);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算 CPU 的使用情况</span></span><br><span class="line">    total1 = user + nice + system + idle + iowait + irq + softirq + steal;</span><br><span class="line">    busy1 = user + nice + system + irq + softirq + steal;</span><br><span class="line">    </span><br><span class="line">    printk(<span class="string">&quot;user is %llu&quot;</span>,user);</span><br><span class="line">    msleep(<span class="number">500</span>);    <span class="comment">// 等待 500ms</span></span><br><span class="line">    </span><br><span class="line">    proc_stat = filp_open(<span class="string">&quot;/proc/stat&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!proc_stat || IS_ERR(proc_stat)) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to open /proc/stat\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = kernel_read(proc_stat, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to read /proc/stat\n&quot;</span>);</span><br><span class="line">        filp_close(proc_stat, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    filp_close(proc_stat, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;cpu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu&quot;</span>, &amp;user, &amp;nice, &amp;system, &amp;idle, &amp;iowait, &amp;irq, &amp;softirq, &amp;steal, &amp;guest, &amp;guest_nice);</span><br><span class="line">    total2 = user + nice + system + idle + iowait + irq + softirq + steal;</span><br><span class="line">    busy2 = user + nice + system + irq + softirq + steal;</span><br><span class="line">    busy = busy2 - busy1;</span><br><span class="line">    usage = (busy * <span class="number">100</span>) / (total2 - total1);</span><br><span class="line">    printk(<span class="string">&quot;cpu total1 is %llu&quot;</span>,total1);</span><br><span class="line">    printk(<span class="string">&quot;cpu total2 is %llu&quot;</span>,total2);</span><br><span class="line">    printk(<span class="string">&quot;cpu busy1 is %llu&quot;</span>,busy1);</span><br><span class="line">    printk(<span class="string">&quot;cpu busy2 is %llu&quot;</span>,busy2);</span><br><span class="line">    printk(<span class="string">&quot;CPU usage: %llu%%\n&quot;</span>, usage);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cpu_usage_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;CPU usage module unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(cpu_usage_init);</span><br><span class="line">module_exit(cpu_usage_exit);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="查看系统内存占用情况">4. 查看系统内存占用情况</h2>
<h3 id="理解sys_info结构">4.1 理解sys_info结构</h3>
<p>"struct sysinfo" 是 Linux 内核中的一个 C
结构体，用于提供关于系统硬件和软件资源的信息。它包含了以下的各个字段，可以通过使用
"sysinfo" 系统调用来获取这些信息。在使用该系统调用时，需要传递一个指向
"struct sysinfo"
结构体的指针作为参数，该结构体将被填充为系统的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. uptime: the number of seconds since the system was last booted.</span><br><span class="line">2. loads: an array of three values representing the average system load over the last 1, 5, and 15 minutes.</span><br><span class="line">3. totalram: the total amount of RAM in kilobytes.</span><br><span class="line">4. freeram: the amount of free RAM in kilobytes.</span><br><span class="line">5. sharedram: the amount of shared memory in kilobytes.</span><br><span class="line">6. bufferram: the amount of buffer memory in kilobytes.</span><br><span class="line">7. totalswap: the total amount of swap space in kilobytes.</span><br><span class="line">8. freeswap: the amount of free swap space in kilobytes.</span><br><span class="line">9. procs: the number of currently running processes.</span><br><span class="line">10. totalhigh: the total amount of high memory in kilobytes (only present on old systems).</span><br><span class="line">11. freehigh: the amount of free high memory in kilobytes (only present on old systems).</span><br><span class="line">12. mem_unit: the size of a single unit of memory in bytes.</span><br></pre></td></tr></table></figure>
<h3 id="理解si_meminfo-函数">4.2 理解si_meminfo 函数</h3>
<p>在 Linux 中，si_meminfo(&amp;sys)
函数是一种用于获取系统内存信息的方式。它是在内核中实现的，可以通过调用该函数来获取系统内存使用情况的详细信息。</p>
<p>该函数的参数是一个指向 "struct sysinfo"
结构体的指针，该结构体包含了关于系统的内存使用情况的信息。si_meminfo(&amp;sys)
函数会填充该结构体的相关字段，以反映系统的内存使用情况。</p>
<p>具体来说，si_meminfo(&amp;sys) 函数会将系统的内存信息填充到 "struct
sysinfo" 结构体的以下字段中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">si_meminfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *val)</span></span><br><span class="line">&#123;</span><br><span class="line">         val-&gt;totalram = totalram_pages;</span><br><span class="line">         val-&gt;sharedram = <span class="number">0</span>;</span><br><span class="line">         val-&gt;freeram = global_page_state(NR_FREE_PAGES);</span><br><span class="line">         val-&gt;bufferram = nr_blockdev_pages();</span><br><span class="line">         val-&gt;totalhigh = totalhigh_pages;</span><br><span class="line">         val-&gt;freehigh = nr_free_highpages();</span><br><span class="line">         val-&gt;mem_unit = PAGE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从sys_info中获取内存使用情况">4.3
从sys_info中获取内存使用情况</h3>
<p>首先创建"struct sysinfo sys" 变量，实际上是一个指向 "struct sysinfo"
结构体的指针，用于接收从系统调用中返回的系统信息。在调用 "sysinfo"
时指定将系统信息存储在哪个变量中。</p>
<p>将"struct sysinfo sys"
变量传给si_meminfo函数。通过调用该函数并解析返回的结构体，我们可以了解系统内存的使用情况，包括系统的总内存大小、当前可用的内存大小、系统缓存和共享内存的使用情况等。</p>
<p>具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/page.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;GuoHongwei&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sysinfo_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">sys</span>;</span></span><br><span class="line"></span><br><span class="line">    si_meminfo(&amp;sys);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;free mem is: %ld\n&quot;</span>, (sys.freeram &lt;&lt; (PAGE_SHIFT - <span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sysinfo_exit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;exit module sysinfo_test\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(sysinfo_init);</span><br><span class="line">module_exit(sysinfo_exit);</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"># linux</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/06/10/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%EF%BC%9AGraphCut-GrabCut-Deep-GrabCut%E8%AF%A6%E8%A7%A3/" rel="prev" title="图像分割：GraphCut-GrabCut-DeepGrabCut详解">
                  <i class="fa fa-angle-left"></i> 图像分割：GraphCut-GrabCut-DeepGrabCut详解
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/07/08/CLIP%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/" rel="next" title="CLIP及其改进工作总结">
                  CLIP及其改进工作总结 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Ultramarine</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
